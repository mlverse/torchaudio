% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/torchaudio.R
\name{torchaudio_load}
\alias{torchaudio_load}
\title{Load Audio File}
\usage{
torchaudio_load(
  filepath,
  out = NULL,
  normalization = TRUE,
  channels_first = TRUE,
  num_frames = 0L,
  offset = 0L,
  signalinfo = NULL,
  encodinginfo = NULL,
  filetype = NULL
)
}
\arguments{
\item{filepath}{(str): Path to audio file}

\item{out}{(Tensor): An optional output tensor to use instead of creating one. (Default: \code{NULL})}

\item{normalization}{(bool, float or function): Optional normalization.
If boolean \code{TRUE}, then output is divided by \code{2^31}.
Assuming the input is signed 32-bit audio, this normalizes to \verb{[-1, 1]}.
If \code{numeric}, then output is divided by that number.
If \code{function}, then the output is passed as a paramete to the given function,
then the output is divided by the result. (Default: \code{TRUE})}

\item{channels_first}{(bool): Set channels first or length first in result. (Default: \code{TRUE})}

\item{num_frames}{(int): Number of frames to load.  0 to load everything after the offset. (Default: \code{0})}

\item{offset}{(int): Number of frames from the start of the file to begin data loading. (Default: \code{0})}

\item{signalinfo}{(str): A sox_signalinfo_t type, which could be helpful if the
audio type cannot be automatically determined. (Default: \code{NULL})}

\item{encodinginfo}{(str): A sox_encodinginfo_t type, which could be set if the
audio type cannot be automatically determined. (Default: \code{NULL})}

\item{filetype}{(str): A filetype or extension to be set if sox cannot determine it
automatically. (Default: \code{NULL})}
}
\value{
\preformatted{list(Tensor, int): An output tensor of size `[C x L]` or `[L x C]` where
    L is the number of audio frames and
    C is the number of channels.
    An integer which is the sample rate of the audio (as listed in the metadata of the file)
}
}
\description{
Loads an audio file from disk into a tensor
}
\examples{
data = torchaudio_load('foo.mp3')
print(data[[1]]$size())
data_vol_normalized = torchaudio_load('foo.mp3', normalization= function(x) torch::torch_abs(x)$max())
print(data_vol_normalized[[1]]$abs()$max())

}
